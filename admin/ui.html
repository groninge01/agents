<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Polymarket Trading Dashboard</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: #333;
      }

      .container {
        max-width: 1680px;
        margin: 0 auto;
      }

      .header {
        background: white;
        padding: 20px 30px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      .header h1 {
        color: #667eea;
        font-size: 28px;
        margin-bottom: 5px;
      }

      .header p {
        color: #666;
        font-size: 14px;
      }

      .main-content {
        display: grid;
        grid-template-columns: 1fr 1.2fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .card {
        background: white;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .card h2 {
        color: #333;
        font-size: 20px;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
      }

      .form-group {
        margin-bottom: 20px;
      }

      .form-group label {
        display: block;
        margin-bottom: 8px;
        color: #555;
        font-weight: 500;
      }

      .form-group input {
        width: 100%;
        padding: 10px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 6px;
        font-size: 14px;
        transition: border-color 0.3s;
      }

      .form-group input:focus {
        outline: none;
        border-color: #667eea;
      }

      .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .checkbox-group input[type='checkbox'] {
        width: auto;
        cursor: pointer;
      }

      .btn {
        padding: 12px 30px;
        border: none;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s;
        width: 100%;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }

      .btn-primary:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background: #f0f0f0;
        color: #333;
      }

      .btn-secondary:hover {
        background: #e0e0e0;
      }

      .log-container {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 15px;
        border-radius: 6px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        max-height: 600px;
        overflow-y: auto;
        line-height: 1.6;
      }

      .log-container::-webkit-scrollbar {
        width: 8px;
      }

      .log-container::-webkit-scrollbar-track {
        background: #2d2d2d;
      }

      .log-container::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }

      .log-line {
        margin-bottom: 2px;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .status-badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 500;
      }

      .status-pending {
        background: #fff3cd;
        color: #856404;
      }

      .status-running {
        background: #cfe2ff;
        color: #084298;
      }

      .status-completed {
        background: #d1e7dd;
        color: #0f5132;
      }

      .status-failed {
        background: #f8d7da;
        color: #842029;
      }

      .task-list {
        max-height: 400px;
        overflow-y: auto;
      }

      .task-item {
        padding: 12px;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .task-item:hover {
        background: #f5f5f5;
        border-color: #667eea;
      }

      .task-item.active {
        background: #f0f4ff;
        border-color: #667eea;
      }

      .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .task-id {
        font-family: monospace;
        font-size: 12px;
        color: #666;
      }

      .task-time {
        font-size: 12px;
        color: #999;
      }

      .task-message {
        font-size: 14px;
        color: #333;
      }

      .alert {
        padding: 12px 15px;
        border-radius: 6px;
        margin-bottom: 15px;
        display: none;
      }

      .alert.show {
        display: block;
      }

      .alert-success {
        background: #d1e7dd;
        color: #0f5132;
        border: 1px solid #badbcc;
      }

      .alert-error {
        background: #f8d7da;
        color: #842029;
        border: 1px solid #f5c2c7;
      }

      .alert-info {
        background: #cfe2ff;
        color: #084298;
        border: 1px solid #b6d4fe;
      }

      .full-width {
        grid-column: 1 / -1;
      }

      .log-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }

      .log-controls button {
        padding: 8px 15px;
        font-size: 14px;
        width: auto;
      }

      .tabs {
        display: flex;
        border-bottom: 2px solid #e0e0e0;
        margin-bottom: 20px;
      }

      .tab-button {
        padding: 12px 24px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        color: #666;
        border-bottom: 3px solid transparent;
        transition: all 0.3s;
      }

      .tab-button:hover {
        color: #667eea;
        background: #f5f5f5;
      }

      .tab-button.active {
        color: #667eea;
        border-bottom-color: #667eea;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .sell-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
      }

      .sell-table th,
      .sell-table td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #e0e0e0;
      }

      .sell-table th {
        background: #f5f5f5;
        font-weight: 600;
        color: #333;
      }

      .sell-table tr:hover {
        background: #f9f9f9;
      }

      .btn-small {
        padding: 6px 16px;
        font-size: 14px;
        width: auto;
      }

      /* Sortable table header */
      .sell-table th.sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
        padding-right: 25px;
      }

      .sell-table th.sortable:hover {
        background: #e8e8e8;
      }

      .sell-table th.sortable::after {
        content: ' ‚áÖ';
        position: absolute;
        right: 8px;
        color: #999;
        font-size: 12px;
      }

      .sell-table th.sortable.sort-asc::after {
        content: ' ‚Üë';
        color: #667eea;
      }

      .sell-table th.sortable.sort-desc::after {
        content: ' ‚Üì';
        color: #667eea;
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
      }

      .modal-content {
        background: white;
        margin: 10% auto;
        padding: 30px;
        border-radius: 10px;
        max-width: 500px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .modal-header {
        margin-bottom: 20px;
      }

      .modal-header h3 {
        color: #333;
        margin: 0;
      }

      .modal-body {
        margin-bottom: 20px;
      }

      .modal-footer {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      @media (max-width: 968px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üöÄ Polymarket Trading Dashboard</h1>
        <p>Buy & Sell Trading Management System</p>
      </div>

      <div class="alert" id="alert"></div>

      <!-- Trading Panel -->
      <div class="card full-width">
        <h2>üí∞ Trading Management</h2>

        <!-- Tab Navigation -->
        <div class="tabs">
          <button class="tab-button" onclick="switchTab('buy')">Buy</button>
          <button class="tab-button active" onclick="switchTab('sell')">
            Sell
          </button>
        </div>

        <!-- Buy Tab -->
        <div id="buyTab" class="tab-content">
          <div class="main-content">
            <div class="card" style="grid-column: 1 / -1">
              <h3>üìä Automated Trading</h3>
              <form id="tradeForm">
                <div class="form-row">
                  <div class="form-group">
                    <label for="numTrades">Number of Orders</label>
                    <input
                      type="number"
                      id="numTrades"
                      name="numTrades"
                      value="3"
                      min="1"
                      max="5"
                      required
                    />
                  </div>
                  <div class="form-group">
                    <label for="amountPerTrade">Amount per Order (USDC)</label>
                    <input
                      type="number"
                      id="amountPerTrade"
                      name="amountPerTrade"
                      value="1.0"
                      min="0.01"
                      max="1.0"
                      step="0.01"
                      required
                    />
                  </div>
                </div>
                <div class="form-group">
                  <div class="checkbox-group">
                    <input type="checkbox" id="dryRun" name="dryRun" />
                    <label for="dryRun">Dry Run (Simulation Mode)</label>
                  </div>
                </div>
                <button type="submit" class="btn btn-primary" id="submitBtn">
                  Execute Buy
                </button>
              </form>

              <div style="margin-top: 25px">
                <h3 style="font-size: 16px; margin-bottom: 15px">
                  Trading History
                </h3>
                <div class="task-list" id="taskList">
                  <div style="text-align: center; color: #999; padding: 20px">
                    No trading records
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Sell Tab -->
        <div id="sellTab" class="tab-content active">
          <div class="form-group">
            <button
              class="btn btn-secondary"
              onclick="refreshSellablePositions(true)"
              style="width: auto"
            >
              Refresh
            </button>
          </div>
          <div id="sellablePositionsContainer">
            <div style="text-align: center; color: #999; padding: 20px">
              Loading sellable positions...
            </div>
          </div>
        </div>
      </div>

      <!-- Trading Logs Panel -->
      <div class="card full-width">
        <h2>üìã Trading Logs</h2>
        <div class="log-controls">
          <button class="btn btn-secondary" onclick="refreshTaskList()">
            Refresh Task List
          </button>
        </div>
        <div class="log-container" id="tradeLogContainer">
          <div style="color: #666; text-align: center; padding: 20px">
            Select a trading task to view logs
          </div>
        </div>
      </div>

      <!-- Buy Confirmation Modal -->
      <div
        id="buyConfirmModal"
        class="modal"
        onclick="if(event.target === this) closeBuyConfirmModal()"
      >
        <div class="modal-content">
          <div class="modal-header">
            <h3>Confirm Buy Order</h3>
          </div>
          <div class="modal-body">
            <div
              style="
                background: #f0f4ff;
                padding: 15px;
                border-radius: 6px;
                margin-bottom: 15px;
              "
            >
              <h4 style="margin: 0 0 10px 0; color: #667eea">Trade Details</h4>
              <div id="buyConfirmDetails" style="line-height: 1.8; color: #333">
                <!-- Trade details will be displayed here -->
              </div>
            </div>
            <div
              style="
                background: #fff3cd;
                padding: 12px;
                border-radius: 6px;
                border-left: 4px solid #ffc107;
              "
            >
              <strong
                >‚ö†Ô∏è Please review the trade information carefully before
                confirming execution</strong
              ><br />
              <small style="color: #856404; margin-top: 8px; display: block">
                üìã After confirmation, you can view the execution logs in the
                "Trading Logs" panel below. The logs will show detailed
                information about each trade execution step.
              </small>
            </div>
          </div>
          <div class="modal-footer">
            <button
              class="btn btn-secondary"
              onclick="closeBuyConfirmModal()"
              style="width: auto"
            >
              Cancel
            </button>
            <button
              class="btn btn-primary"
              onclick="executeBuyTrade()"
              style="width: auto"
            >
              Confirm Execute
            </button>
          </div>
        </div>
      </div>

      <!-- Sell Modal -->
      <div
        id="sellModal"
        class="modal"
        onclick="if(event.target === this) closeSellModal()"
      >
        <div class="modal-content">
          <div class="modal-header">
            <h3>Sell Position</h3>
          </div>
          <div class="modal-body">
            <div class="form-group">
              <label>Market</label>
              <div
                id="sellModalMarket"
                style="padding: 10px; background: #f5f5f5; border-radius: 6px"
              ></div>
            </div>
            <div
              style="
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 15px;
                margin-bottom: 15px;
              "
            >
              <div class="form-group">
                <label>Ask Price</label>
                <div
                  id="sellModalBuyPrice"
                  style="padding: 10px; background: #f5f5f5; border-radius: 6px"
                ></div>
              </div>
              <div class="form-group">
                <label>Bid Price</label>
                <div
                  id="sellModalBidPrice"
                  style="padding: 10px; background: #f5f5f5; border-radius: 6px"
                ></div>
              </div>
            </div>
            <div class="form-group">
              <label>Available Shares</label>
              <div
                id="sellModalShares"
                style="padding: 10px; background: #f5f5f5; border-radius: 6px"
              ></div>
            </div>
            <div class="form-group">
              <label for="sellSharesInput">Sell Shares</label>
              <input
                type="number"
                id="sellSharesInput"
                min="0.000001"
                step="0.000001"
                required
              />
            </div>
            <div class="form-group">
              <label>Estimated P&L</label>
              <div
                id="sellModalPnl"
                style="
                  padding: 10px;
                  background: #f5f5f5;
                  border-radius: 6px;
                  font-weight: 600;
                "
              ></div>
            </div>
          </div>
          <div class="modal-footer">
            <button
              class="btn btn-secondary"
              onclick="closeSellModal()"
              style="width: auto"
            >
              Cancel
            </button>
            <button
              class="btn btn-primary"
              onclick="confirmSell()"
              style="width: auto"
            >
              Confirm Sell
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let monitorLogEventSource = null;
      let tradeLogEventSource = null;
      let currentTaskId = null;
      let pnlSortDirection = null; // 'asc', 'desc', or null

      // Initialize on page load
      window.addEventListener('load', () => {
        refreshTaskList();
        refreshSellablePositions();
        // ‚ö†Ô∏è Auto-refresh has been fully removed to avoid API rate limiting
        // The positions list will not auto-refresh; please click Refresh manually
      });

      // Tab switching functionality
      function switchTab(tabName) {
        // Update tab button states
        document.querySelectorAll('.tab-button').forEach((btn, index) => {
          btn.classList.remove('active');
          if (
            (tabName === 'buy' && index === 0) ||
            (tabName === 'sell' && index === 1)
          ) {
            btn.classList.add('active');
          }
        });

        // Update tab content display
        document.querySelectorAll('.tab-content').forEach((content) => {
          content.classList.remove('active');
        });
        document.getElementById(tabName + 'Tab').classList.add('active');

        // Refresh positions list when switching to sell tab
        if (tabName === 'sell') {
          refreshSellablePositions();
        }
      }

      // Refresh sellable positions list
      async function refreshSellablePositions(showLoading = true) {
        const container = document.getElementById('sellablePositionsContainer');

        // Show loading state only on first load or manual refresh
        if (
          showLoading &&
          (!container.innerHTML ||
            container.innerHTML.includes('Loading') ||
            container.innerHTML.includes('No sellable positions'))
        ) {
          container.innerHTML =
            '<div style="text-align: center; color: #999; padding: 20px;">Loading...</div>';
        }

        try {
          const response = await fetch('/api/positions/sellable');
          if (!response.ok) {
            throw new Error('Failed to fetch positions list');
          }

          const data = await response.json();

          if (data.positions.length === 0) {
            container.innerHTML =
              '<div style="text-align: center; color: #999; padding: 20px;">No sellable positions</div>';
            return;
          }

          // Calculate summary data
          const totalCost = data.positions.reduce(
            (sum, pos) => sum + pos.cost,
            0
          );
          const totalValue = data.total_value;
          const totalPnl = totalValue - totalCost;
          const totalPnlPct = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
          const totalPnlColor = totalPnl >= 0 ? '#0f5132' : '#842029';

          // Sort positions by P&L if sort direction is set
          let positions = [...data.positions];
          if (pnlSortDirection === 'asc') {
            positions.sort((a, b) => a.pnl - b.pnl);
          } else if (pnlSortDirection === 'desc') {
            positions.sort((a, b) => b.pnl - a.pnl);
          }

          // Create table
          let tableHTML = `
                    <table class="sell-table">
                        <thead>
                            <tr>
                                <th>Market</th>
                                <th>Side</th>
                                <th>Ask Price</th>
                                <th>Bid Price</th>
                                <th>Shares</th>
                                <th>Cost</th>
                                <th>Value</th>
                                <th class="sortable" id="pnlHeader" onclick="sortByPnl()">P&L</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

          positions.forEach((pos) => {
            const pnlColor = pos.pnl >= 0 ? '#0f5132' : '#842029';
            // If value is 0 (or close to 0), do not show the Sell button
            const showSellButton = pos.value > 0.01;
            const actionCell = showSellButton
              ? `<button class="btn btn-primary btn-small" onclick="openSellModal('${
                  pos.token_id
                }', '${pos.market.replace(/'/g, "\\'")}', ${pos.shares}, ${
                  pos.bid_price
                }, ${pos.buy_price})">Sell</button>`
              : '<span style="color: #999;">-</span>';

            tableHTML += `
                        <tr>
                            <td>${
                              pos.market.length > 40
                                ? pos.market.substring(0, 40) + '...'
                                : pos.market
                            }</td>
                            <td>${pos.side}</td>
                            <td>$${pos.buy_price.toFixed(4)}</td>
                            <td>$${pos.bid_price.toFixed(4)}</td>
                            <td>${pos.shares.toFixed(6)}</td>
                            <td>$${pos.cost.toFixed(2)}</td>
                            <td>$${pos.value.toFixed(2)}</td>
                            <td style="color: ${pnlColor};">$${
              pos.pnl >= 0 ? '+' : ''
            }${pos.pnl.toFixed(2)} (${
              pos.pnl_pct >= 0 ? '+' : ''
            }${pos.pnl_pct.toFixed(2)}%)</td>
                            <td>${actionCell}</td>
                        </tr>
                    `;
          });

          // Add summary row
          tableHTML += `
                        </tbody>
                        <tfoot>
                            <tr style="background: #f5f5f5; font-weight: 600; border-top: 2px solid #667eea;">
                                <td colspan="5" style="text-align: right; padding-right: 15px;">Total:</td>
                                <td style="color: #333;">$${totalCost.toFixed(
                                  2
                                )}</td>
                                <td style="color: #333;">$${totalValue.toFixed(
                                  2
                                )}</td>
                                <td style="color: ${totalPnlColor}; font-size: 16px;">$${
            totalPnl >= 0 ? '+' : ''
          }${totalPnl.toFixed(2)} (${
            totalPnlPct >= 0 ? '+' : ''
          }${totalPnlPct.toFixed(2)}%)</td>
                                <td></td>
                            </tr>
                        </tfoot>
                    </table>
                    <div style="margin-top: 15px; text-align: right; font-weight: 600; color: #666;">
                        Total: ${data.count} position${
            data.count !== 1 ? 's' : ''
          }
                    </div>
                `;

          container.innerHTML = tableHTML;

          // Update sort indicator after table is inserted
          const pnlHeader = document.getElementById('pnlHeader');
          if (pnlHeader) {
            pnlHeader.classList.remove('sort-asc', 'sort-desc');
            if (pnlSortDirection === 'asc') {
              pnlHeader.classList.add('sort-asc');
            } else if (pnlSortDirection === 'desc') {
              pnlHeader.classList.add('sort-desc');
            }
          }
        } catch (error) {
          container.innerHTML = `<div style="text-align: center; color: #ff6b6b; padding: 20px;">Failed to load: ${error.message}</div>`;
        }
      }

      // Open sell modal
      let currentSellPosition = null;
      function openSellModal(tokenId, market, shares, bidPrice, buyPrice) {
        currentSellPosition = { tokenId, market, shares, bidPrice, buyPrice };

        const modal = document.getElementById('sellModal');
        document.getElementById('sellModalMarket').textContent = market;
        document.getElementById('sellModalShares').textContent =
          shares.toFixed(6);
        document.getElementById('sellModalBidPrice').textContent =
          '$' + bidPrice.toFixed(4);
        document.getElementById('sellModalBuyPrice').textContent =
          '$' + buyPrice.toFixed(4);

        // Calculate estimated P&L
        const estimatedPnl = (bidPrice - buyPrice) * shares;
        const estimatedPnlPct = ((bidPrice - buyPrice) / buyPrice) * 100;
        const pnlColor = estimatedPnl >= 0 ? '#0f5132' : '#842029';
        document.getElementById(
          'sellModalPnl'
        ).innerHTML = `<span style="color: ${pnlColor};">$${
          estimatedPnl >= 0 ? '+' : ''
        }${estimatedPnl.toFixed(2)} (${
          estimatedPnlPct >= 0 ? '+' : ''
        }${estimatedPnlPct.toFixed(2)}%)</span>`;

        document.getElementById('sellSharesInput').value = shares.toFixed(6);
        document.getElementById('sellSharesInput').max = shares;

        modal.style.display = 'block';
      }

      // Close modal
      function closeSellModal() {
        document.getElementById('sellModal').style.display = 'none';
        currentSellPosition = null;
      }

      // Sort by P&L
      function sortByPnl() {
        // Toggle sort direction: null -> desc -> asc -> null
        if (pnlSortDirection === null) {
          pnlSortDirection = 'desc'; // Start with descending (highest profit first)
        } else if (pnlSortDirection === 'desc') {
          pnlSortDirection = 'asc'; // Then ascending (lowest profit/loss first)
        } else {
          pnlSortDirection = null; // Finally reset to original order
        }
        // Refresh positions list with new sort
        refreshSellablePositions(false);
      }

      // Confirm sell
      async function confirmSell() {
        if (!currentSellPosition) return;

        const sellShares = parseFloat(
          document.getElementById('sellSharesInput').value
        );
        if (sellShares <= 0 || sellShares > currentSellPosition.shares) {
          showAlert('Invalid sell quantity', 'error');
          return;
        }

        const estimatedProfit = (
          (currentSellPosition.bidPrice - currentSellPosition.buyPrice) *
          sellShares
        ).toFixed(2);
        if (
          !confirm(
            `Are you sure you want to sell ${sellShares.toFixed(
              6
            )} shares?\nEstimated Profit: $${estimatedProfit}`
          )
        ) {
          return;
        }

        try {
          const response = await fetch('/api/positions/sell', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              token_id: currentSellPosition.tokenId,
              shares: sellShares,
              reason: 'Manual sell',
            }),
          });

          if (!response.ok) {
            let errorDetail = 'Sell failed';
            try {
              const errorData = await response.json();
              console.error('Sell API error:', errorData);
              // Handle different error message formats
              if (typeof errorData === 'string') {
                errorDetail = errorData;
              } else if (errorData.detail) {
                errorDetail = errorData.detail;
                // If it's an array (FastAPI validation error), convert to string
                if (Array.isArray(errorData.detail)) {
                  errorDetail = errorData.detail
                    .map((e) => e.msg || JSON.stringify(e))
                    .join('; ');
                }
              } else if (errorData.message) {
                errorDetail = errorData.message;
              } else {
                errorDetail = JSON.stringify(errorData);
              }
            } catch (e) {
              console.error('Error parsing error response:', e);
              errorDetail = `HTTP ${response.status}: ${response.statusText}`;
            }
            throw new Error(errorDetail);
          }

          const result = await response.json();
          console.log('Sell result:', result);
          showAlert(result.message || 'Sell executed successfully', 'success');
          closeSellModal();

          // Refresh positions list after a short delay
          setTimeout(() => {
            refreshSellablePositions();
          }, 1000);
        } catch (error) {
          console.error('Sell error:', error);
          let errorMessage = error.message || 'Sell failed';

          // Display error - handle multiline messages
          if (errorMessage.includes('\n')) {
            const firstLine = errorMessage.split('\n')[0];
            showAlert(
              `Sell failed: ${firstLine} (See console for details)`,
              'error'
            );
            console.error('Full error message:', errorMessage);
          } else {
            showAlert('Sell failed: ' + errorMessage, 'error');
          }
        }
      }

      // Load monitor configuration
      async function loadMonitorConfig() {
        try {
          const response = await fetch('/api/monitor/config');
          if (response.ok) {
            const config = await response.json();
            document.getElementById('takeProfitPct').textContent = (
              config.take_profit_pct * 100
            ).toFixed(0);
            document.getElementById('stopLossPct').textContent = (
              config.stop_loss_pct * 100
            ).toFixed(0);
            document.getElementById('monitorInterval').textContent =
              config.monitor_interval;
            document.getElementById('autoExecute').textContent =
              config.auto_execute ? 'Enabled' : 'Disabled';

            if (config.auto_execute) {
              document.getElementById('autoExecuteInfo').style.color =
                '#dc2626';
            }
          }
        } catch (error) {
          console.error('Failed to load monitor configuration:', error);
        }
      }

      // Check monitor status
      async function checkMonitorStatus() {
        try {
          const response = await fetch('/api/monitor/status');
          if (response.ok) {
            const status = await response.json();
            const statusBadge = document.getElementById('monitorStatus');
            if (status.running) {
              statusBadge.textContent = `Running (PID: ${status.pid})`;
              statusBadge.className = 'status-badge status-running';
            } else {
              statusBadge.textContent = 'Not Running';
              statusBadge.className = 'status-badge status-pending';
            }
          }
        } catch (error) {
          console.error('Failed to check monitor status:', error);
        }
      }

      // Start monitor process
      async function startMonitorProcess() {
        const buttons = document.querySelectorAll('button');
        const startButton = Array.from(buttons).find((btn) =>
          btn.textContent.includes('Start Monitor Process')
        );

        if (startButton) {
          startButton.disabled = true;
          startButton.textContent = 'Starting...';
        }

        try {
          // Set timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

          const response = await fetch('/api/monitor/start', {
            method: 'POST',
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const result = await response.json();

          if (
            result.status === 'started' ||
            result.status === 'already_running'
          ) {
            showAlert(result.message, 'success');
            // Update status (delayed check to allow process startup)
            setTimeout(checkMonitorStatus, 2000);
            // Automatically start viewing logs
            setTimeout(() => {
              startMonitorLogs();
            }, 3000);
          } else {
            showAlert(result.message || 'Start failed', 'error');
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            showAlert(
              'Start timeout, please check if monitor process has started',
              'error'
            );
          } else {
            showAlert(
              'Failed to start monitor process: ' + error.message,
              'error'
            );
          }
        } finally {
          if (startButton) {
            startButton.disabled = false;
            startButton.textContent = 'Start Monitor Process';
          }
          // Check status
          setTimeout(checkMonitorStatus, 1000);
        }
      }

      // Stop monitor process
      async function stopMonitorProcess() {
        if (!confirm('Are you sure you want to stop the monitor process?')) {
          return;
        }

        try {
          const response = await fetch('/api/monitor/stop', {
            method: 'POST',
          });

          const result = await response.json();
          showAlert(result.message, 'info');
          // Update status
          setTimeout(checkMonitorStatus, 1000);
        } catch (error) {
          showAlert(
            'Failed to stop monitor process: ' + error.message,
            'error'
          );
        }
      }

      // Show alert message
      function showAlert(message, type = 'info') {
        const alert = document.getElementById('alert');
        alert.textContent = message;
        alert.className = `alert alert-${type} show`;

        setTimeout(() => {
          alert.classList.remove('show');
        }, 5000);
      }

      // Store pending trade data
      let pendingTradeData = null;

      // Submit trade form - show confirmation first
      document
        .getElementById('tradeForm')
        .addEventListener('submit', async (e) => {
          e.preventDefault();

          const numTrades = parseInt(
            document.getElementById('numTrades').value
          );
          const amountPerTrade = parseFloat(
            document.getElementById('amountPerTrade').value
          );
          const dryRun = document.getElementById('dryRun').checked;

          // Validate inputs
          if (isNaN(numTrades) || numTrades < 1 || numTrades > 5) {
            showAlert('Number of orders must be between 1 and 5', 'error');
            return;
          }

          if (
            isNaN(amountPerTrade) ||
            amountPerTrade <= 0 ||
            amountPerTrade > 1.0
          ) {
            showAlert(
              'Amount per order must be between 0.01 and 1.0 USDC',
              'error'
            );
            return;
          }

          // Save trade data - ensure correct types
          pendingTradeData = {
            num_trades: Number(numTrades),
            amount_per_trade: Number(amountPerTrade),
            trade_type: 'buy',
            dry_run: Boolean(dryRun),
          };

          console.log('Prepared trade data:', pendingTradeData);

          // Show confirmation modal
          showBuyConfirmModal(numTrades, amountPerTrade, dryRun);
        });

      // Show buy confirmation modal
      function showBuyConfirmModal(numTrades, amountPerTrade, dryRun) {
        const totalAmount = (numTrades * amountPerTrade).toFixed(2);
        const modeText = dryRun
          ? '<span style="color: #ffc107; font-weight: 600;">üîí DRY RUN MODE - No real trades will be executed!</span>'
          : '<span style="color: #dc2626; font-weight: 600; font-size: 16px;">‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è LIVE TRADING MODE - Real money will be used! ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è</span>';

        const detailsHTML = `
                <div><strong>Trade Type:</strong> Buy</div>
                <div><strong>Number of Orders:</strong> ${numTrades} market${
          numTrades !== 1 ? 's' : ''
        }</div>
                <div><strong>Amount per Order:</strong> $${amountPerTrade.toFixed(
                  2
                )} USDC</div>
                <div><strong>Total Amount:</strong> <span style="font-size: 18px; font-weight: 600; color: #667eea;">$${totalAmount} USDC</span></div>
                <div style="margin-top: 15px; padding: 15px; border-radius: 6px; ${
                  dryRun
                    ? 'background: #fff3cd; border-left: 4px solid #ffc107;'
                    : 'background: #f8d7da; border-left: 4px solid #dc2626;'
                }">
                    <strong>Execution Mode:</strong><br>${modeText}
                </div>
            `;

        document.getElementById('buyConfirmDetails').innerHTML = detailsHTML;
        document.getElementById('buyConfirmModal').style.display = 'block';
      }

      // Close buy confirmation modal
      function closeBuyConfirmModal() {
        document.getElementById('buyConfirmModal').style.display = 'none';
        pendingTradeData = null;
      }

      // Execute buy trade after confirmation
      async function executeBuyTrade() {
        if (!pendingTradeData) {
          showAlert('Trade data not found', 'error');
          return;
        }

        // Save trade data before closing modal (modal close will clear pendingTradeData)
        const tradeDataToSend = { ...pendingTradeData };

        // Close modal (this will set pendingTradeData to null, but we have a copy)
        closeBuyConfirmModal();

        const submitBtn = document.getElementById('submitBtn');
        submitBtn.disabled = true;
        submitBtn.textContent = 'Executing...';

        try {
          // Log request data before sending
          console.log(
            'Sending trade request:',
            JSON.stringify(tradeDataToSend, null, 2)
          );

          const response = await fetch('/api/trade/execute', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(tradeDataToSend),
          });

          console.log('Response status:', response.status);

          if (!response.ok) {
            let errorDetail = 'Execution failed';
            try {
              const errorData = await response.json();
              console.error('API error response:', errorData);
              console.error('Error status:', response.status);

              // Handle 422 validation errors with detailed messages
              if (response.status === 422) {
                if (Array.isArray(errorData.detail)) {
                  errorDetail =
                    'Validation Error:\n' +
                    errorData.detail
                      .map((e) => {
                        // Handle both old format (e.loc) and new format (e.field)
                        let field = '';
                        if (e.field) {
                          field = e.field;
                        } else if (Array.isArray(e.loc)) {
                          field = e.loc.slice(1).join('.');
                        } else {
                          field = String(e.loc || 'unknown');
                        }
                        const msg = e.msg || e.message || 'Validation error';
                        return `‚Ä¢ ${field}: ${msg}`;
                      })
                      .join('\n');
                } else if (typeof errorData.detail === 'string') {
                  errorDetail = errorData.detail;
                } else if (errorData.message) {
                  errorDetail = errorData.message;
                } else {
                  errorDetail =
                    'Validation Error: ' +
                    JSON.stringify(errorData.detail || errorData, null, 2);
                }
              } else {
                errorDetail =
                  errorData.detail ||
                  errorData.message ||
                  `HTTP ${response.status}: ${response.statusText}`;
              }
            } catch (e) {
              console.error('Error parsing error response:', e);
              errorDetail = `HTTP ${response.status}: ${response.statusText}. Unable to parse error details.`;
            }
            console.error(
              'Request data that caused error:',
              JSON.stringify(tradeDataToSend, null, 2)
            );
            throw new Error(errorDetail);
          }

          const result = await response.json();
          console.log('Trade execution response:', result);
          const modeText =
            tradeDataToSend && tradeDataToSend.dry_run
              ? ' (Dry Run Mode - Simulation only)'
              : ' (Live Trading Mode - Real trades executing)';
          showAlert(
            `Trading task started! Task ID: ${result.task_id}${modeText}. Check logs below.`,
            'success'
          );

          // Refresh task list and show logs immediately
          setTimeout(() => {
            refreshTaskList();
            // Auto view new task logs to see execution progress
            viewTradeLogs(result.task_id);
          }, 500);
        } catch (error) {
          console.error('Trade execution error:', error);
          console.error('Error stack:', error.stack);
          console.error('Trade data that was sent:', tradeDataToSend);

          // Error message is already set from the response parsing above
          let errorMessage = error.message || 'Execution failed';

          // Display error - handle multiline messages
          if (errorMessage.includes('\n')) {
            // For multiline errors, show first line in alert, full message in console
            const firstLine = errorMessage.split('\n')[0];
            showAlert(
              `Execution failed: ${firstLine} (See console for details)`,
              'error'
            );
            console.error('Full error message:', errorMessage);
          } else {
            showAlert(`Execution failed: ${errorMessage}`, 'error');
          }
        } finally {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Execute Buy';
          // Don't clear pendingTradeData here as it's already cleared by closeBuyConfirmModal()
        }
      }

      // Refresh task list
      async function refreshTaskList() {
        try {
          const response = await fetch('/api/trade/list');

          if (!response.ok) {
            throw new Error('Failed to fetch task list');
          }

          const data = await response.json();
          const taskList = document.getElementById('taskList');

          if (data.tasks.length === 0) {
            taskList.innerHTML =
              '<div style="text-align: center; color: #999; padding: 20px;">No trading records</div>';
            return;
          }

          taskList.innerHTML = data.tasks
            .map((task) => {
              const statusClass = `status-${task.status}`;
              const startTime = task.start_time
                ? new Date(task.start_time).toLocaleString('en-US')
                : '-';

              return `
                        <div class="task-item ${
                          task.task_id === currentTaskId ? 'active' : ''
                        }"
                             onclick="viewTradeLogs('${task.task_id}')">
                            <div class="task-header">
                                <span class="task-id">${task.task_id}</span>
                                <span class="status-badge ${statusClass}">${getStatusText(
                task.status
              )}</span>
                            </div>
                            <div class="task-message">${task.message}</div>
                            <div class="task-time">Start Time: ${startTime}</div>
                        </div>
                    `;
            })
            .join('');
        } catch (error) {
          showAlert(`Failed to fetch task list: ${error.message}`, 'error');
        }
      }

      // Get status text
      function getStatusText(status) {
        const statusMap = {
          pending: 'Pending',
          running: 'Running',
          completed: 'Completed',
          failed: 'Failed',
        };
        return statusMap[status] || status;
      }

      // View trade logs
      function viewTradeLogs(taskId) {
        currentTaskId = taskId;

        // Stop current log stream
        if (tradeLogEventSource) {
          tradeLogEventSource.close();
        }

        const container = document.getElementById('tradeLogContainer');
        container.innerHTML =
          '<div style="color: #888;">Loading logs... Please wait, execution may take a few minutes.</div>';

        // Update task list highlight
        document.querySelectorAll('.task-item').forEach((item) => {
          item.classList.remove('active');
          if (item.querySelector('.task-id').textContent === taskId) {
            item.classList.add('active');
          }
        });

        // Create EventSource connection
        tradeLogEventSource = new EventSource(`/api/logs/trade/${taskId}`);

        tradeLogEventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);

            if (data.error) {
              container.innerHTML += `<div style="color: #ff6b6b;">Error: ${data.error}</div>`;
              return;
            }

            if (data.line) {
              const logLine = document.createElement('div');
              logLine.className = 'log-line';
              logLine.textContent = data.line;
              container.appendChild(logLine);
              container.scrollTop = container.scrollHeight;
            }
          } catch (e) {
            console.error('Failed to parse log data:', e);
          }
        };

        tradeLogEventSource.onerror = (error) => {
          console.error('Log stream error:', error);
          if (tradeLogEventSource.readyState === EventSource.CLOSED) {
            container.innerHTML +=
              '<div style="color: #888;">Log stream closed</div>';
          }
        };
      }

      // Start monitor logs
      function startMonitorLogs() {
        if (monitorLogEventSource) {
          showAlert('Monitor already running', 'info');
          return;
        }

        const container = document.getElementById('monitorLogContainer');
        container.innerHTML =
          '<div style="color: #888;">Connecting to log stream...</div>';

        // Clear container (but keep initial message)
        container.innerHTML = '';

        // Create EventSource connection
        monitorLogEventSource = new EventSource(`/api/logs/monitor`);

        monitorLogEventSource.onmessage = (event) => {
          // Skip heartbeat messages
          if (!event.data || event.data.trim().startsWith(':')) {
            return;
          }

          try {
            const data = JSON.parse(event.data);

            if (data.error) {
              const errorLine = document.createElement('div');
              errorLine.className = 'log-line';
              errorLine.style.color = '#ff6b6b';
              errorLine.textContent = `[Error] ${data.error}`;
              container.appendChild(errorLine);
              container.scrollTop = container.scrollHeight;
              return;
            }

            if (data.line) {
              const logLine = document.createElement('div');
              logLine.className = 'log-line';
              logLine.textContent = data.line;
              container.appendChild(logLine);
              // Auto scroll to bottom (use requestAnimationFrame to ensure scroll works)
              requestAnimationFrame(() => {
                container.scrollTop = container.scrollHeight;
              });
            }
          } catch (e) {
            // If parsing fails, might be non-JSON data (e.g., heartbeat), ignore it
            console.debug('Skipping non-JSON data:', event.data);
          }
        };

        monitorLogEventSource.onopen = () => {
          console.log('Log stream connection established');
          container.innerHTML =
            '<div style="color: #888;">Log stream connected, waiting for log data...</div>';
        };

        monitorLogEventSource.onerror = (error) => {
          console.error('Log stream error:', error);

          if (monitorLogEventSource.readyState === EventSource.CLOSED) {
            container.innerHTML +=
              '<div style="color: #ff6b6b;">Log stream disconnected, please restart monitoring</div>';
            monitorLogEventSource = null;
            showAlert('Log stream connection disconnected', 'error');
          } else if (
            monitorLogEventSource.readyState === EventSource.CONNECTING
          ) {
            container.innerHTML +=
              '<div style="color: #ffaa00;">Reconnecting...</div>';
          }
        };

        showAlert('Monitor started', 'success');
      }

      // Stop monitor logs
      function stopMonitorLogs() {
        if (monitorLogEventSource) {
          monitorLogEventSource.close();
          monitorLogEventSource = null;
          showAlert('Monitor stopped', 'info');
        }
      }

      // Clear log display
      function clearLogs() {
        document.getElementById('monitorLogContainer').innerHTML = '';
        document.getElementById('tradeLogContainer').innerHTML = '';
        showAlert('Log display cleared', 'info');
      }

      // ‚ö†Ô∏è Auto-refresh for task list has been removed to avoid API rate limiting
      // The task list will not auto-refresh; please click Refresh Task List manually
    </script>
  </body>
</html>
